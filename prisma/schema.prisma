generator client {
  provider = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Sparar specialiseringar per yrke (AI-genererade)
model ProfessionSpecialization {
  id              Int      @id @default(autoincrement())
  profession      String
  language        String   @default("sv") // Language code: sv, en, es, fr, de
  specializations Json     // Array of specialization strings
  hitCount        Int      @default(0) // Hur många gånger detta yrke sökts
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@unique([profession, language])
  @@index([profession])
  @@index([language])
}

// Sparar vanliga arbetsuppgifter per yrke + specialisering
model CommonTasks {
  id              Int      @id @default(autoincrement())
  profession      String
  specialization  String
  language        String   @default("sv") // Language code: sv, en, es, fr, de
  tasks           Json     // Array of common tasks
  hitCount        Int      @default(0)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@unique([profession, specialization, language])
  @@index([profession])
  @@index([specialization])
  @@index([language])
}

// Sparar genererade task-lösningar och prompts (cache för snabbare laddning)
model TaskSolution {
  id              String   @id @default(cuid())
  profession      String
  specialization  String
  task            String   @db.Text // Arbetsuppgiften
  solution        String   @db.Text // Lösningsbeskrivning
  prompt          String   @db.Text // Den genererade prompten
  language        String   @default("sv")
  
  // Analytics
  hitCount        Int      @default(0)
  usedInAnalyses  Int      @default(0)
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@unique([profession, specialization, task, language])
  @@index([profession, specialization])
  @@index([hitCount])
  @@index([language])
}

// Sparar kompletta AI-rekommendationer (för snabbare laddning)
model RecommendationCache {
  id              Int      @id @default(autoincrement())
  cacheKey        String   @unique // Hash of profession+specialization+tasks
  profession      String
  specialization  String
  tasks           Json     // Array of tasks with priorities
  experience      String?
  challenges      Json?    // Array of challenges
  
  // Cached AI responses
  recommendations Json     // Array of AI tool recommendations
  scenarios       Json     // Array of real-world scenarios
  inferredTasks   Json?    // Array of inferred tasks
  
  // Metadata
  hitCount        Int      @default(0)
  lastUsed        DateTime @default(now())
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Indexes for faster queries
  @@index([profession, specialization])
  @@index([lastUsed])
  @@index([hitCount])
}

// Sparar användarinteraktioner för analytics och förbättringar
model UserSession {
  id              String   @id @default(cuid())
  
  // User journey
  profession      String
  specialization  String?
  experience      String?
  selectedTasks   Json?    // Array of tasks user selected
  challenges      Json?    // Array of challenges
  
  // Behavior tracking
  viewedTools     Json?    // Which tools they clicked on
  copiedPrompts   Json?    // Which prompts they copied
  timeSpent       Int?     // Seconds spent on results page
  completedSteps  Int      @default(0) // How far they got (1-4)
  
  // Conversion tracking
  clickedPremium  Boolean  @default(false)
  
  // Metadata
  userAgent       String?
  referrer        String?
  createdAt       DateTime @default(now())
  
  @@index([profession])
  @@index([createdAt])
}

// Sparar feedback från användare
model Feedback {
  id                 Int      @id @default(autoincrement())
  sessionId          String?
  
  // Context
  profession         String
  specialization     String?
  recommendationName String?  // Which tool they gave feedback on
  
  // Feedback
  rating             Int?     // 1-5 stars
  helpful            Boolean?
  comment            String?
  
  createdAt          DateTime @default(now())
  
  @@index([profession])
  @@index([recommendationName])
  @@index([rating])
}

// Sparar populära kombinationer för snabbare suggestions
model PopularCombinations {
  id              Int      @id @default(autoincrement())
  profession      String
  specialization  String
  taskCombination Json     // Array of commonly selected tasks together
  frequency       Int      @default(1)
  lastSeen        DateTime @default(now())
  
  @@unique([profession, specialization])
  @@index([frequency])
}

// Sparar delningsresultat
model SharedResult {
  id            String   @id @default(cuid())
  shareId       String   @unique
  profession    String
  specialization String?
  tasks         Json
  recommendations Json
  scenarios     Json?
  email         String?  // For magic link retrieval
  createdAt     DateTime @default(now())
  expiresAt     DateTime
  
  @@index([email])
}

// Sparar chat-historik för AI-coach
model ChatHistory {
  id         String   @id @default(cuid())
  userType   String   // "consumer" or "business"
  profession String?
  department String?
  message    String
  response   String   @db.Text
  createdAt  DateTime @default(now())
  sessionId  String?  // To group conversations
  
  @@index([userType])
  @@index([sessionId])
  @@index([createdAt])
}

// Sparar AI-genererade prompts per yrke
model PromptLibrary {
  id              String   @id @default(cuid())
  profession      String
  specialization  String?
  category        String   // e.g., "Dokumentation", "Kommunikation"
  name            String
  description     String
  
  // Värdeförklaring
  challenge       String   @db.Text  // Vilken utmaning löser denna prompt?
  solution        String   @db.Text  // Hur löser prompten utmaningen?
  bestPractice    String   @db.Text  // Bästa sättet att använda prompten
  realWorldExample String? @db.Text  // Verkligt exempel på användning
  expectedOutcome String   @db.Text  // Vad kan användaren förvänta sig?
  
  // Själva prompten och variationer
  prompt          String   @db.Text
  promptVariants  Json?    // Alternativa versioner för olika AI-modeller
  
  // Framtidssäkring
  agentReady      Boolean  @default(false)  // Fungerar med AI-agenter
  multiModal      Boolean  @default(false)  // Stödjer bild/ljud/video
  apiIntegration  Json?    // Info om API-integrationer
  automation      Json?    // Automationsworkflows
  
  timeSaved       String   // e.g., "2-3h/vecka"
  difficulty      String   // "Lätt", "Medel", "Avancerat"
  example         String?  @db.Text
  howToUse        String?  @db.Text
  tools           Json     // Array of tool names
  tags            Json?    // Array of tags for search
  usageCount      Int      @default(0)
  rating          Float?   // Average user rating
  isPremium       Boolean  @default(false)
  aiModel         String   @default("gpt-5")
  supportedModels Json     @default("[]") // ["gpt-4", "gpt-5", "claude-3", "gemini"]
  industry        String?
  companySize     String?
  experienceLevel String?
  language        String   @default("sv")
  
  // Multi-language support
  translations    Json?    // Översättningar för alla fält
  // Structure: {
  //   "en": { name, description, challenge, solution, bestPractice, expectedOutcome, prompt },
  //   "es": { ... },
  //   "fr": { ... },
  //   "de": { ... }
  // }
  translatedAt    DateTime?
  autoTranslated  Boolean  @default(false)
  
  version         Int      @default(1)
  parentId        String?  // For tracking prompt iterations
  createdBy       String?  // User who created it
  verifiedBy      String?  // Admin who verified it
  isVerified      Boolean  @default(false)
  lastUsed        DateTime?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Relations
  ratings         PromptRating[]
  usageLogs       PromptUsageLog[]
  
  @@index([profession, specialization])
  @@index([category])
  @@index([usageCount])
  @@index([profession, category])
  @@index([isPremium])
  @@index([rating])
  @@index([agentReady])
}

model PromptRating {
  id         String   @id @default(cuid())
  promptId   String
  userId     String
  rating     Int      // 1-5
  comment    String?
  createdAt  DateTime @default(now())
  
  prompt     PromptLibrary @relation(fields: [promptId], references: [id])
  
  @@unique([promptId, userId])
  @@index([promptId])
}

model PromptUsageLog {
  id         String   @id @default(cuid())
  promptId   String
  userId     String?
  sessionId  String?
  copied     Boolean  @default(false)
  createdAt  DateTime @default(now())
  
  prompt     PromptLibrary @relation(fields: [promptId], references: [id])
  
  @@index([promptId])
  @@index([userId])
}

model Subscription {
  id            String   @id @default(cuid())
  userId        String   @unique
  email         String
  tier          String   // "free", "professional", "business"
  status        String   // "active", "cancelled", "expired", "trial"
  stripeCustomerId    String?
  stripeSubscriptionId String?
  currentPeriodStart  DateTime
  currentPeriodEnd    DateTime
  cancelAtPeriodEnd   Boolean @default(false)
  
  // Access levels
  promptAccess  String   @default("limited") // "limited", "profession", "unlimited"
  monthlyPromptLimit Int? // null = unlimited
  usedPrompts   Int      @default(0)
  
  // Premium features
  hasAICoach    Boolean  @default(false)
  hasPDFReports Boolean  @default(false)
  hasAPIAccess  Boolean  @default(false)
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@index([email])
  @@index([status])
}

enum UserRole {
  ADMIN
  USER
  VIEWER
}

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  name          String?
  profession    String?
  company       String?
  password      String?   // For internal users
  isInternal    Boolean   @default(false)
  role          UserRole  @default(USER)
  permissions   Json?     // Additional fine-grained permissions
  lastLogin     DateTime?
  companyId     String?
  companyRef    Company?  @relation(fields: [companyId], references: [id])
  
  bots          Bot[]
  integrations  Integration[]
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  @@index([email])
  @@index([companyId])
  @@index([role])
}

model Company {
  id            String   @id @default(cuid())
  name          String
  code          String   @unique // Company code for signup
  emailDomain   String?  // e.g., "company.com" to validate email domains
  isActive      Boolean  @default(true)
  
  users         User[]
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@index([code])
}

// Business flow: company-specific prompts and metadata
model BusinessSolution {
  id              String   @id @default(cuid())
  companyUrl      String
  department      String
  task            String   @db.Text
  solution        String   @db.Text
  prompt          String   @db.Text
  recommendedTool String?
  language        String   @default("sv")
  createdAt       DateTime @default(now())
  
  @@index([companyUrl, department])
}

// Executive flow: interview logs (conversation turns/history)
model ExecutiveConversation {
  id           String   @id @default(cuid())
  sessionId    String?
  companyUrl   String?
  problem      String
  conversation Json
  createdAt    DateTime @default(now())
  
  @@index([sessionId])
  @@index([companyUrl])
}

// Executive flow: generated deep-dive solutions
model ExecutiveSolution {
  id                String   @id @default(cuid())
  companyUrl        String?
  problem           String
  analysis          String   @db.Text
  approach          String
  prompt            String?  @db.Text
  botInstructions   Json?
  expectedOutcomes  Json
  createdAt         DateTime @default(now())
  
  @@index([companyUrl])
}

// Bot provisioning
model Bot {
  id           String   @id @default(cuid())
  userId       String?  // Owner of the bot
  companyUrl   String?
  name         String
  type         String   // "knowledge" | "lead" | "support" | "workflow"
  spec         Json     // Full konfiguration: roll, mål, verktyg
  embeddingKey String?  // referens till vektorindex/namespace
  isActive     Boolean  @default(true)
  isPublic     Boolean  @default(false) // Marketplace visibility
  cloneCount   Int      @default(0) // How many times cloned
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  user         User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  sources      BotSource[]
  usages       BotUsage[]
  approvals    ApprovalRequest[]
  versions     BotVersion[]
  evals        BotEval[]
  actions      BotAction[]
  integration  BotIntegration?
  knowledge    BotKnowledge[]
  integrationConnections BotIntegrationConnection[]
  sessions     BotSession[]
  ratings      BotRating[]
  qaDatabase   BotQA[]
  agentProfile AgentProfile?
  
  @@index([companyUrl])
  @@index([userId])
  @@index([isPublic])
}

// Bot ratings for marketplace
model BotRating {
  id        String   @id @default(cuid())
  botId     String
  userId    String
  rating    Int      // 1-5
  comment   String?  @db.Text
  createdAt DateTime @default(now())
  
  bot       Bot      @relation(fields: [botId], references: [id], onDelete: Cascade)
  
  @@unique([botId, userId])
  @@index([botId])
  @@index([rating])
}

// RAG: Vector embeddings for semantic search (using JSONB for Railway compatibility)
model BotKnowledge {
  id          String   @id @default(cuid())
  botId       String
  sourceUrl   String?  // Original URL
  title       String
  content     String   @db.Text
  embedding   Json?    // OpenAI ada-002 embedding as JSON array [float, float, ...]
  metadata    Json?    // { section, date, author, etc }
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  bot         Bot      @relation(fields: [botId], references: [id], onDelete: Cascade)
  
  @@index([botId])
  @@index([sourceUrl])
}

// Question-Answer pairs for structured RAG
model BotQA {
  id            String   @id @default(cuid())
  botId         String
  
  // Question and answer
  question      String   @db.Text
  answer        String   @db.Text
  category      String   // "customer" | "internal" | "faq" | "policy" | "product" | "support"
  
  // Quality metrics
  confidence    Float    @default(0) // 0-1, GPT's confidence in answer
  verified      Boolean  @default(false) // Admin verified
  verifiedBy    String?  // Admin user ID who verified
  verifiedAt    DateTime?
  
  // Source tracking
  sourceUrl     String?  // Where this Q&A came from
  sourceType    String   @default("generated") // "generated" | "faq_detected" | "manual"
  
  // Usage stats
  hitCount      Int      @default(0) // How many times this Q&A was used
  feedbackScore Float?   // Average user feedback (1-5)
  feedbackCount Int      @default(0)
  
  // Search optimization
  keywords      Json?    // Array of keywords for faster matching
  relatedQuestions Json? // Array of similar questions
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  bot           Bot      @relation(fields: [botId], references: [id], onDelete: Cascade)
  
  @@index([botId])
  @@index([category])
  @@index([verified])
  @@index([confidence])
  @@index([hitCount])
}

// Session tracking for multi-turn conversations
model BotSession {
  id          String   @id @default(cuid())
  botId       String
  userId      String?  // Optional: if user is logged in
  ip          String?
  userAgent   String?
  messages    Json     // Array of {role, content, timestamp}
  metadata    Json?    // { lead_captured, booking_made, etc }
  
  // Archive support
  isArchived  Boolean  @default(false)
  archivedAt  DateTime?
  
  // Search optimization
  searchText  String?  @db.Text // Extracted text for full-text search
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  bot         Bot      @relation(fields: [botId], references: [id], onDelete: Cascade)
  
  @@index([botId])
  @@index([userId])
  @@index([isArchived])
  @@index([createdAt])
}

model BotSource {
  id        String   @id @default(cuid())
  botId     String
  kind      String   // "website" | "document"
  url       String?  // för website
  filename  String?  // för dokument
  meta      Json?
  createdAt DateTime @default(now())
  
  bot       Bot      @relation(fields: [botId], references: [id])
  
  @@index([botId])
}

model BotUsage {
  id        String   @id @default(cuid())
  botId     String
  userId    String?
  kind      String   // "message" | "action"
  tokens    Int?     // valfritt
  createdAt DateTime @default(now())
  
  bot       Bot      @relation(fields: [botId], references: [id])
  
  @@index([botId])
  @@index([createdAt])
}

// Encrypted integration credentials per bot
model BotIntegration {
  id                   String   @id @default(cuid())
  botId                String   @unique

  // Zendesk
  zendeskDomain        String?
  zendeskEmail         String?
  zendeskApiTokenEnc   String?  // AES-GCM encrypted

  // HubSpot
  hubspotTokenEnc      String?

  // Shopify
  shopifyDomain        String?
  shopifyAccessTokenEnc String?

  // Centra (Headless Commerce)
  centraApiBaseUrl     String?
  centraStoreId        String?
  centraAccessTokenEnc String?

  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  bot                  Bot      @relation(fields: [botId], references: [id], onDelete: Cascade)

  @@index([botId])
}

// New: General purpose integrations (webhook, slack, etc)
model Integration {
  id        String   @id @default(cuid())
  userId    String
  type      String   // "webhook" | "slack" | "teams" | "discord" | "zapier" | "email" | "sms" | "calendar" | "crm" | "analytics" | "database" | "api"
  name      String
  settings  Json     // Type-specific settings (URLs, tokens, etc)
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  botIntegrations BotIntegrationConnection[]
  
  @@index([userId])
  @@index([type])
}

// Many-to-many connection between bots and integrations
model BotIntegrationConnection {
  id            String   @id @default(cuid())
  botId         String
  integrationId String
  config        Json?    // Bot-specific config for this integration
  createdAt     DateTime @default(now())
  
  bot           Bot          @relation(fields: [botId], references: [id], onDelete: Cascade)
  integration   Integration  @relation(fields: [integrationId], references: [id], onDelete: Cascade)
  
  @@unique([botId, integrationId])
  @@index([botId])
  @@index([integrationId])
}

model BotVersion {
  id        String   @id @default(cuid())
  botId     String
  version   Int
  spec      Json
  createdAt DateTime @default(now())

  bot       Bot @relation(fields: [botId], references: [id])

  @@unique([botId, version])
  @@index([botId])
}

model BotEval {
  id            String   @id @default(cuid())
  botId         String
  name          String
  input         String   @db.Text
  expectedMatch String
  lastRunAt     DateTime?
  lastPass      Boolean?
  lastReply     String?  @db.Text

  bot           Bot @relation(fields: [botId], references: [id])

  @@index([botId])
}

// Approval queue for external actions
model ApprovalRequest {
  id         String   @id @default(cuid())
  botId      String
  type       String   // "lead" | "support"
  payload    Json
  status     String   @default("pending") // pending | approved | rejected
  createdAt  DateTime @default(now())
  approvedAt DateTime?
  approvedBy String?

  bot        Bot      @relation(fields: [botId], references: [id])

  @@index([botId])
  @@index([status])
}

// Internal inbox for vendor‑agnostic actions (lead/support)
model BotAction {
  id         String   @id @default(cuid())
  botId      String
  type       String   // lead|support
  payload    Json
  status     String   @default("stored") // stored|emailed|slacked|webhooked
  createdAt  DateTime @default(now())

  bot        Bot      @relation(fields: [botId], references: [id])

  @@index([botId])
  @@index([type])
  @@index([createdAt])
}

// Due Diligence entities
model DDCompany {
  id        String   @id @default(cuid())
  url       String   @unique
  name      String?
  createdAt DateTime @default(now())

  analyses  DDAnalysis[]
  metrics   DDMetric[]
}

model DDAnalysis {
  id         String   @id @default(cuid())
  companyId  String
  version    Int      @default(1)
  profile    Json
  scoring    Json
  createdAt  DateTime @default(now())

  company    DDCompany @relation(fields: [companyId], references: [id])

  @@index([companyId])
}

model DDMetric {
  id         String   @id @default(cuid())
  companyId  String
  category   String   // financials | sales | support | web | hr
  key        String   // e.g., ARR, MRR, CAC
  period     String   // e.g., 2025-09, 2024, Q1-2025
  value      Float
  source     String   // scrape | customer | assumption | file
  createdAt  DateTime @default(now())

  company    DDCompany @relation(fields: [companyId], references: [id])

  @@index([companyId])
  @@index([category])
  @@index([key, period])
}

// Store scrape summaries to aid analytics and debugging
model CompanyScrapeRun {
  id              String   @id @default(cuid())
  url             String
  summary         Json
  content         String?  @db.Text
  pages           Int?
  totalTextLength Int?
  createdAt       DateTime @default(now())
  
  @@index([url])
}

// ============= AGENT SYSTEM =============
// Agenttyper - kan läggas till dynamiskt
model AgentType {
  id              String   @id @default(cuid())
  slug            String   @unique // "customer_service", "finance", "creative"
  name            String   // "Mr. Black - Customer Service"
  description     String   @db.Text
  mascot          String   // "mr_black.png", "mrs_pink.png", "mr_green.png"
  color           String   // #000000, #FF69B4, #00AA00
  
  // Standardfråga för denna agenttyp
  onboardingPrompt String @db.Text
  
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  categories      AgentCategory[]
  profiles        AgentProfile[]
  onboardingSteps OnboardingStep[]
  
  @@index([slug])
}

// Kategorier - hierarkisk struktur (kan vara många nivåer djup!)
model AgentCategory {
  id              String   @id @default(cuid())
  agentTypeId     String   // Vilken agenttyp denna kategori tillhör
  parentId        String?  // För hierarki: null = huvudkategori
  
  name            String   // "Kundstöd", "Fakturering", etc
  slug            String   // "customer_support", "invoicing"
  description     String   @db.Text
  order           Int      @default(0) // Sort order inom samma nivå
  
  // Vad ska vi fråga användaren om denna kategori?
  contextQuestions Json   // ["Vilka är dina vanligaste kundfrågor?", "..."]
  
  // Meta för RAG/AI
  tags            Json?    // ["support", "technical", "urgent"]
  icon            String?  // Lucide icon name
  
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  agentType       AgentType @relation(fields: [agentTypeId], references: [id], onDelete: Cascade)
  parent          AgentCategory? @relation("ChildCategories", fields: [parentId], references: [id])
  children        AgentCategory[] @relation("ChildCategories")
  useCases        UseCaseTemplate[]
  
  @@unique([agentTypeId, slug])
  @@index([agentTypeId])
  @@index([parentId])
}

// Use case templates - vad kan agenten göra?
model UseCaseTemplate {
  id              String   @id @default(cuid())
  categoryId      String
  
  name            String   // "Lead Qualification"
  description     String   @db.Text
  icon            String?
  order           Int      @default(0)
  
  // Instruktioner för denna use case
  systemPromptTemplate String @db.Text // "{...} Your role is to {{role}}"
  contextTemplate Json?    // Variabler som ska fyllas i
  
  // Exempel på vad agenten kan göra
  exampleTasks    Json?    // ["Bedöm qualification", "Boka möte", ...]
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  category        AgentCategory @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  
  @@index([categoryId])
}

// Användarens agentprofil - sparar all context
model AgentProfile {
  id              String   @id @default(cuid())
  botId           String   @unique
  agentTypeId     String   // Vilken agenttyp
  
  // Användarens "väg genom trädet"
  selectedCategoryPath Json // ["customer_service", "support", "faq_based"]
  selectedUseCases Json?   // Array av UseCaseTemplate IDs eller slugs
  
  // Strukturerad kontext från onboarding
  onboardingResponses Json  // { "question_slug": "answer_text", ... }
  
  // Genererad kontext för GPT
  generatedContext Json?    // {
                            //   industry: "SaaS",
                            //   companySize: "10-50",
                            //   mainChallenges: [...],
                            //   targetAudience: "Enterprise",
                            //   customInstructions: "..."
                            // }
  
  // Personaliserad system prompt
  systemPrompt    String   @db.Text
  
  // Metadata
  onboardingCompleted Boolean @default(false)
  onboardingVersion Int     @default(1)
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  bot             Bot      @relation(fields: [botId], references: [id], onDelete: Cascade)
  agentType       AgentType @relation(fields: [agentTypeId], references: [id])
  
  @@index([botId])
  @@index([agentTypeId])
}

// Onboarding steps - varje fråga i processen
model OnboardingStep {
  id              String   @id @default(cuid())
  agentTypeId     String   // Vilken agenttyp denna step tillhör
  
  stepNumber      Int      // 1, 2, 3...
  questionText    String   @db.Text
  helpText        String?  @db.Text
  
  // Hur ska vi fråga?
  questionType    String   // "multiple_choice", "text", "tree_selection", "ai_generated"
  options         Json?    // För multiple_choice: [{ label, value }, ...]
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  agentType       AgentType @relation(fields: [agentTypeId], references: [id], onDelete: Cascade)
  
  @@index([agentTypeId, stepNumber])
}